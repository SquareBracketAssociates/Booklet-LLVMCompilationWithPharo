## Unicorn### Unicorn Presentation\([Unicorn](https://www.unicorn-engine.org/)\) is an extension of \([QEMU](https://www.qemu.org/)\),an open-source software emulator. Unicorn is a lightweight multi-platform,multi-architecture CPU emulator framework. It is implemented in C but hasbindings written in several popular languages such as Java, Python, Go or Pharo.It supports multiple architecture emulations \(Arm, Mips, X86\) and provides asimple and thread-safe API to emulate the architectures.Now, what is the link between Unicorn, a CPU emulator and the rest of our LLVMbindings?While our bindings are foreign function calls to the C api of LLVM, we have nopractical insurance, from a Pharo point of view, that that everything will workas expected. Tests on bindings are hard to write because the majority of thecreated objects are external address pointing to the actual objects generated bythe foreign function. When looking at LLVM, emulating a CPU then performingour LLVM bindings operations and looking at the final state of the emulated CPUis the type of environment we need to perform some tests.Our workflow would consist of setting up an emulated CPU, using our bindings andlooking at their impact and consequences on the CPU. This will help us test ourbindings and ensure everything works as expected. The way we plan on doing thisis by using the generated machine code as instructions to pass directly to theemulated CPU \(coherently being the `TargetMachine`\).### Unicorn TutorialThe tutorial of Unicorn comes as the presentation of the Unicorn Pharo bindingsthat can be found \([here](https://github.com/guillep/pharo-unicorn)\). Thistutorial is the Pharo port of the one that can be found on the official Unicorn\([website](https://www.unicorn-engine.org/docs/tutorial.html)\).What we will do in this example is:- Create an emulator with 2MB of memory,- Write two instructions: Increase ECX, Decrease EDX,- Initialise ECX and EDX,- Run the program,- Retrieve the values of the registers#### Creating an Unicorn engineThe first step is to create a unicorn engine. It is the Pharo fa√ßade object thatholds the other methods from Unicorn. Several architectures are implemented andyou can access them through class methods defined in the `Unicorn` class.```language=Pharoengine := Unicorn arm.
engine := Unicorn x86.```#### Manipulating MemoryOnce the engine is ready, we have to allocate memory to it. We can do so in twodifferent ways, by either mapping a new chunk of memory of a given size using themethod `mapMemoryOfSize:` or mapping an existing piece of memory \(what wouldbe a Pharo `ByteArray`\) using the method `mapHostMemory:`.The first method can be written as follows:```language=Pharoengine mapMemoryOfSize: 2 * 1024 * 1024
       atAddress: 16r1000000.
       withPermissions: UnicornConstants permissionAll```The second method would translate as:```language=Pharoengine mapHostMemory: aByteArray
       atAddress: 16r1000000.
       withPermissions: UnicornConstants permissionAll```Note that in both cases, we chose the same address `16r1000000` \(startingaddress or the emulation\) and the same type of permissions `UnicornConstants permissionAll`that enables `READ`, `WRITE` and `EXECUTE` access over the piece of memory.The different permissions can be chosen using the different class methods of`UnicornConstants`. You can therefore use `permissionAll`, `permissionNone`or `permissionRead`, `permissionWrite` and `permissionExecute`.On the other hand, you can read and write memory \(if given the correct permissions\)with the methods `memoryAt:write:` and `memoryAt:readNext:` to write a bytearray at a given address or read into one from the memory at a given address.#### Manipulating RegistersThe registers are the basis of a CPU. They are specific to each architecture andhave different names and common functionalities. Here, we will look at the onesof an X86 architecture, and especially `ECX` and `EDX`.To create your registers and initialise them, you can do so by using the classmethods of the `UcX86Registers` class. In our case, we will need:```language=Pharoecx := UcX86Registers ecx.
edx := UcX86Registers edx.```You can find all the other types of register in the class methods with forexample `eax`, `ebx`, `r9`, `r10`, etc.Now, in order to allocate values to the registers, we have to use the method`register:write:`. We can allocate values coming as `ByteArray`s as follows:```language=PharoecxValue := #[ 16r34 16r12  ]. "0x1234"
edxValue := #[ 16r90 16r78 ].  "0x7890"

unicorn register: ecx value write: ecxValue.
unicorn register: edx value write: edxValue.```#### Emulation and ResultsWe can now emulate the CPU and any instruction we want it to execute. Theinstruction we chose is `INC ecx; DEC edx` which is translated into`x41` and `x4a`.This instruction can be put up for execution by using:```language=Pharox86_CODE32 := #[ 16r41 16r4a ]. "INC ecx; DEC edx"
errorCode := engine atAddress: 16r1000000
                    write: x86_CODE32
                    size: x86_CODE32 size.```Note that the method `atAddress:write:size:` outputs an error code that can bestored and displayed.Now in order to launch the emulation, you have to choose a parameter that willstop it. You can choose from:- An address in memory to go up to,- A timeout value to stop after,- An instruction count to stop after.Here, we will choose the first method and tell it to stop after executing ourtwo instructions. This can be done as follows:```language=PharoerrorCode := unicorn startAt: address
                     until: address + x86_CODE32 size
                     timeout: 0
                     count: 0.```Once again, this method outputs an error code that can be stored and displayed.In order to look into the registers to see if anything has changed, we can usethe `register:readInto:` method.```language=PharoecxValue := #[ 16r12 16r34 ]. "Previous values: #[18 52]"
edxValue := #[ 16r78 16r90 ]. "Previous values: #[120 144]"

unicorn register: ecx value readInto: ecxValue.
unicorn register: edx value readInto: edxValue.

ecxValue. "New values: #[19 52]"
edxValue. "New values: #[119 144]"```We can see that our instructions have been properly emulated!### Testing an LLVM instruction