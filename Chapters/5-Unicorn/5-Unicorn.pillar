!!Unicorn

!!!Unicorn Presentation

(*Unicorn>https://www.unicorn-engine.org/*) is an extension of (*QEMU>https://www.qemu.org/*),
an open-source software emulator. Unicorn is a lightweight multi-platform,
multi-architecture CPU emulator framework. It is implemented in C but has
bindings written in several popular languages such as Java, Python, Go or Pharo.
It supports multiple architecture emulations (Arm, Mips, X86) and provides a
simple and thread-safe API to emulate the architectures.

Now, what is the link between Unicorn, a CPU emulator and the rest of our LLVM
bindings?

While our bindings are foreign function calls to the C api of LLVM, we have no
practical insurance, from a Pharo point of view, that that everything will work
as expected. Tests on bindings are hard to write because the majority of the
created objects are external address pointing to the actual objects generated by
the foreign function. When looking at LLVM, emulating a CPU then performing
our LLVM bindings operations and looking at the final state of the emulated CPU
is the type of environment we need to perform some tests.

Our workflow would consist of setting up an emulated CPU, using our bindings and
looking at their impact and consequences on the CPU. This will help us test our
bindings and ensure everything works as expected. The way we plan on doing this
is by using the generated machine code as instructions to pass directly to the
emulated CPU (coherently being the ==TargetMachine==).

!!!Unicorn Tutorial

The tutorial of Unicorn comes as the presentation of the Unicorn Pharo bindings
that can be found (*here>https://github.com/guillep/pharo-unicorn*). This
tutorial is the Pharo port of the one that can be found on the official Unicorn
(*website>https://www.unicorn-engine.org/docs/tutorial.html*).

What we will do in this example is:
-Create an emulator with 2MB of memory,
-Write two instructions: Increase ECX, Decrease EDX,
-Initialise ECX and EDX,
-Run the program,
-Retrieve the values of the registers

!!!!Creating an Unicorn engine

The first step is to create a unicorn engine. It is the Pharo fa√ßade object that
holds the other methods from Unicorn. Several architectures are implemented and
you can access them through class methods defined in the ==Unicorn== class.

[[[language=Pharo
engine := Unicorn arm.
engine := Unicorn x86.
]]]

!!!!Manipulating Memory

Once the engine is ready, we have to allocate memory to it. We can do so in two
different ways, by either mapping a new chunk of memory of a given size using the
method ==mapMemoryOfSize:== or mapping an existing piece of memory (what would
be a Pharo ==ByteArray==) using the method ==mapHostMemory:==.

The first method can be written as follows:
[[[language=Pharo
engine mapMemoryOfSize: 2 * 1024 * 1024
       atAddress: 16r1000000.
       withPermissions: UnicornConstants permissionAll
]]]

The second method would translate as:
[[[language=Pharo
engine mapHostMemory: aByteArray
       atAddress: 16r1000000.
       withPermissions: UnicornConstants permissionAll
]]]

Note that in both cases, we chose the same address ==16r1000000== (starting
address or the emulation) and the same type of permissions ==UnicornConstants permissionAll==
that enables ==READ==, ==WRITE== and ==EXECUTE== access over the piece of memory.
The different permissions can be chosen using the different class methods of
==UnicornConstants==. You can therefore use ==permissionAll==, ==permissionNone==
or ==permissionRead==, ==permissionWrite== and ==permissionExecute==.

On the other hand, you can read and write memory (if given the correct permissions)
with the methods ==memoryAt:write:== and ==memoryAt:readNext:== to write a byte
array at a given address or read into one from the memory at a given address.

!!!!Manipulating Registers

The registers are the basis of a CPU. They are specific to each architecture and
have different names and common functionalities. Here, we will look at the ones
of an X86 architecture, and especially ==ECX== and ==EDX==.

To create your registers and initialise them, you can do so by using the class
methods of the ==UcX86Registers== class. In our case, we will need:
[[[language=Pharo
ecx := UcX86Registers ecx.
edx := UcX86Registers edx.
]]]

You can find all the other types of register in the class methods with for
example ==eax==, ==ebx==, ==r9==, ==r10==, etc.

Now, in order to allocate values to the registers, we have to use the method
==register:write:==. We can allocate values coming as ==ByteArray==s as follows:

[[[language=Pharo
ecxValue := #[ 16r34 16r12  ]. "0x1234"
edxValue := #[ 16r90 16r78 ].  "0x7890"

unicorn register: ecx value write: ecxValue.
unicorn register: edx value write: edxValue.
]]]

!!!!Emulation and Results

We can now emulate the CPU and any instruction we want it to execute. The
instruction we chose is ==INC ecx; DEC edx== which is translated into
==x41== and ==x4a==.

This instruction can be put up for execution by using:
[[[language=Pharo
x86_CODE32 := #[ 16r41 16r4a ]. "INC ecx; DEC edx"
errorCode := engine atAddress: 16r1000000
                    write: x86_CODE32
                    size: x86_CODE32 size.
]]]

Note that the method ==atAddress:write:size:== outputs an error code that can be
stored and displayed.

Now in order to launch the emulation, you have to choose a parameter that will
stop it. You can choose from:
-An address in memory to go up to,
-A timeout value to stop after,
-An instruction count to stop after.

Here, we will choose the first method and tell it to stop after executing our
two instructions. This can be done as follows:
[[[language=Pharo
errorCode := unicorn startAt: address
                     until: address + x86_CODE32 size
                     timeout: 0
                     count: 0.
]]]

Once again, this method outputs an error code that can be stored and displayed.

In order to look into the registers to see if anything has changed, we can use
the ==register:readInto:== method.

[[[language=Pharo
ecxValue := #[ 16r12 16r34 ]. "Previous values: #[18 52]"
edxValue := #[ 16r78 16r90 ]. "Previous values: #[120 144]"

unicorn register: ecx value readInto: ecxValue.
unicorn register: edx value readInto: edxValue.

ecxValue. "New values: #[19 52]"
edxValue. "New values: #[119 144]"
]]]

We can see that our instructions have been properly emulated!


!!!Testing an LLVM instruction
